//
//     Attention: Generated code! Do not modify by hand!
//     Generated by: AbstractPersistenceTestCase.vsl in andromda-grails-cartridge.
package com.mogobiz

import grails.test.GrailsUnitTestCase
import org.codehaus.groovy.grails.commons.DefaultGrailsApplication
import org.codehaus.groovy.grails.commons.GrailsApplication
import org.codehaus.groovy.grails.commons.spring.DefaultRuntimeSpringConfiguration
import org.codehaus.groovy.grails.commons.spring.GrailsRuntimeConfigurator
import org.codehaus.groovy.grails.plugins.datasource.DataSourceGrailsPlugin
import org.codehaus.groovy.grails.plugins.i18n.I18nGrailsPlugin
import org.codehaus.groovy.grails.support.MockApplicationContext
import org.hibernate.Session
import org.hibernate.SessionFactory
import org.springframework.context.ApplicationContext
import org.springframework.context.support.StaticMessageSource
import org.springframework.orm.hibernate3.SessionFactoryUtils
import org.springframework.orm.hibernate3.SessionHolder
import org.springframework.transaction.TransactionStatus
import org.springframework.transaction.support.AbstractPlatformTransactionManager
import org.springframework.transaction.support.DefaultTransactionDefinition
import org.springframework.transaction.support.TransactionSynchronizationManager
import org.codehaus.groovy.grails.plugins.*

import java.sql.SQLException
import java.text.SimpleDateFormat

abstract class AbstractPersistenceTestCase extends GrailsUnitTestCase {
    GroovyClassLoader gcl = new GroovyClassLoader(this.getClass().classLoader)
    MockApplicationContext ctx
    ApplicationContext appCtx
    AbstractPlatformTransactionManager transactionManager
    /**
     * Statut de la transaction englobante
     */
    private TransactionStatus transactionStatus
    /**
     * 
     */
    boolean commit
    SessionFactory sessionFactory
    Session session

    protected void setUp() {
        super.setUp()

        ExpandoMetaClass.enableGlobally()

        GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()

        gcl.parseClass('''
dataSource {
    pooled = true
    driverClassName = "org.postgresql.Driver"
    url = "jdbc:postgresql://localhost/iper2010"
    username = "iper2010"
    password = "iper2010"
    dialect = "org.hibernate.dialect.IperSQLDialect"
    logSql = "false"
}
hibernate {
    jta.UserTransaction = "UserTransaction"
    session_factory_name = "java:/hibernate/SessionFactory"
    cache.use_query_cache = "true"
    cache.provider_class = "org.hibernate.cache.EhCacheProvider"
    cache.query_cache_factory = "org.hibernate.cache.StandardQueryCacheFactory"
    connection.release_mode = "auto"
// database hibernateProperties merge-point
}
''', "DataSource")

        ctx = new MockApplicationContext()

        def classes = getDomainClasses()

        gcl.getLoadedClasses().each {
            classes << it
        }

        def ga = new DefaultGrailsApplication(classes as Class[], gcl)
        def mockManager = new MockGrailsPluginManager(ga)
        ctx.registerMockBean("manager", mockManager)
        PluginManagerHolder.setPluginManager(mockManager)

        def dependentPlugins = [
                DataSourceGrailsPlugin,
                DomainClassGrailsPlugin,
                I18nGrailsPlugin,
                MockHibernateGrailsPlugin
        ].collect { new DefaultGrailsPlugin(it, ga)}

        dependentPlugins.each { mockManager.registerMockPlugin(it); it.manager = mockManager }
        mockManager.doArtefactConfiguration()
        ctx.registerMockBean(PluginMetaManager.BEAN_ID, new DefaultPluginMetaManager())

        ga.initialise()
        ga.setApplicationContext(ctx)
        ApplicationHolder.setApplication(ga)
        ctx.registerMockBean(GrailsApplication.APPLICATION_ID, ga)
        ctx.registerMockBean("messageSource", new StaticMessageSource())

        def springConfig = new DefaultRuntimeSpringConfiguration(ctx, gcl)
        dependentPlugins*.doWithRuntimeConfiguration(springConfig)

        appCtx = springConfig.getApplicationContext()
        dependentPlugins*.doWithApplicationContext(appCtx)

        mockManager.applicationContext = appCtx
        mockManager.doDynamicMethods()

        sessionFactory = appCtx.getBean(GrailsRuntimeConfigurator.SESSION_FACTORY_BEAN)

        transactionManager = appCtx.getBean(GrailsRuntimeConfigurator.TRANSACTION_MANAGER_BEAN)
        commit = false
        try {
            log.info("Ouverture d'une transaction pour le test")
            transactionStatus = transactionManager.getTransaction(new DefaultTransactionDefinition())
        }
        catch (Exception ex) {
            log.info("Echec d'ouverture d'une transaction pour le test -> " + ex.getMessage())
        }
        
        if (!TransactionSynchronizationManager.hasResource(sessionFactory)) {
            session = sessionFactory.openSession()
            TransactionSynchronizationManager.bindResource(sessionFactory, new SessionHolder(session))
        }
    }

    List getDomainClasses(){
		return [
		     com.mogobiz.geolocation.domain.PoiType
		    ,com.mogobiz.geolocation.domain.Location
		    ,com.mogobiz.geolocation.domain.Poi
		    ,com.mogobiz.store.domain.Role
		    ,com.mogobiz.store.domain.ExternalAccount
		    ,com.mogobiz.store.domain.Interest
		    ,com.mogobiz.store.domain.VariationValue
		    ,com.mogobiz.store.domain.Seller
		    ,com.mogobiz.store.domain.TicketType
		    ,com.mogobiz.store.domain.TaxRate
		    ,com.mogobiz.store.domain.Brand
		    ,com.mogobiz.store.domain.IntraDayPeriod
		    ,com.mogobiz.store.domain.Feature
		    ,com.mogobiz.store.domain.ExternalAuthLogin
		    ,com.mogobiz.store.domain.Event
		    ,com.mogobiz.store.domain.Consumption
		    ,com.mogobiz.store.domain.Permission
		    ,com.mogobiz.store.domain.Tag
		    ,com.mogobiz.store.domain.Album
		    ,com.mogobiz.store.domain.Product
		    ,com.mogobiz.store.domain.User
		    ,com.mogobiz.store.domain.StockCalendar
		    ,com.mogobiz.store.domain.Variation
		    ,com.mogobiz.store.domain.UserPermission
		    ,com.mogobiz.store.domain.EventPeriodSale
		    ,com.mogobiz.store.domain.BOTicketType
		    ,com.mogobiz.store.domain.Suggestion
		    ,com.mogobiz.store.domain.Shipping
		    ,com.mogobiz.store.domain.RolePermission
		    ,com.mogobiz.store.domain.Category
		    ,com.mogobiz.store.domain.Resource
		    ,com.mogobiz.store.domain.Product2Resource
		    ,com.mogobiz.store.domain.BOProduct
		    ,com.mogobiz.store.domain.Company
		    ,com.mogobiz.store.domain.DatePeriod
		]
	}

    protected void tearDown() {
        try {
            if (commit) {
                log.info("Commit de la transaction pour le test")
                transactionManager.commit(transactionStatus)
            }
            else {
                log.info("Rollback de la transaction pour le test")
                transactionManager.rollback(transactionStatus)
            }
        }
        catch (Exception ex) {
            if (commit) {
                log.info("Echec du commit de la transaction pour le test -> " + ex.getMessage())
            }
            else {
                log.info("Echec du rollback de la transaction pour le test -> " + ex.getMessage())
            }
        }
        if (TransactionSynchronizationManager.hasResource(this.sessionFactory)) {
            SessionHolder holder = (SessionHolder) TransactionSynchronizationManager.getResource(this.sessionFactory)
            org.hibernate.Session s = holder.getSession()
            //s.flush()
            TransactionSynchronizationManager.unbindResource(this.sessionFactory)
            SessionFactoryUtils.releaseSession(s, this.sessionFactory)
        }

        ApplicationHolder.setApplication(null)
        ExpandoMetaClass.disableGlobally()
        PluginManagerHolder.setPluginManager(null)

        super.tearDown()
    }

    /**
     * @param classe
     *            -
     * @param path
     *            -
     */
    protected void runSqlFile(Class classe, String path)
    {
        runSqlFile(classe.getResourceAsStream(path))
    }

    /**
     * @param classe
     *            -
     * @param path
     *            -
     * @param params
     *            -
     */
    protected void runSqlFile(Class classe, String path, Object... params)
    {
        runSqlFile(classe.getResourceAsStream(path), params)
    }

    /**
     * Permet de lancer les requï¿½tes contenu dans le fichier accessible depuis
     * AbstractPersistenceTestCase.class avec le path donnï¿½
     * 
     * @param path
     *            -
     */
    protected void runSqlFile(String path)
    {
        runSqlFile(AbstractPersistenceTestCase.class.getResourceAsStream("/" + path))
    }

    /**
     * Permet de lancer les requï¿½tes contenues dans le fichier accessible depuis
     * AbstractPersistenceTestCase.class avec le path donnï¿½
     * 
     * @param path
     *            -
     * @param params
     *            -
     */
    protected void runSqlFile(String path, Object... params)
    {
        runSqlFile(AbstractPersistenceTestCase.class.getResourceAsStream("/" + path), params)
    }

    /**
     * Permet de lancer les requï¿½tes contenues dans l'input. Les requï¿½tes sont
     * sï¿½parï¿½es par un ";"
     * 
     * @param input
     *            -
     * @param params
     *            -
     */
    protected void runSqlFile(InputStream input, Object... params)
    {
        StringBuffer contenu = null

        try
        {
            contenu = readInput(input)
        }
        catch (IOException ex)
        {
            fail(ex.getMessage())
        }

        String[] tabSQL = contenu.toString().split(";")
        for (String sql : tabSQL)
        {
            if (sql.trim().length() > 0)
            {
                for (int i = 0; i < params.length; i++)
                {
                    StringBuffer str = new StringBuffer("\\{").append(i).append("\\}")
                    String valeurParam = ""
                    if (params[i] != null)
                    {
                        if (params[i] instanceof Calendar)
                        {
                            SimpleDateFormat format = new SimpleDateFormat("dd/MM/yy HH:mm:ss")
                            valeurParam = format.format(((Calendar) params[i]).getTime())
                        }
                        else
                        {
                            valeurParam = params[i].toString()
                        }
                    }
                    sql = sql.replaceAll(str.toString(), valeurParam)
                }
                try
                {
                    getSession().connection().prepareStatement(sql.trim()).execute()
                }
                catch (SQLException ex)
                {
                    fail(ex.getMessage())
                }
            }
        }
    }

    /**
     * 
     * @param input
     *            - input stream
     * @return {@link StringBuffer}
     * @throws IOException
     *             -
     */
    private StringBuffer readInput(InputStream input) throws IOException {
        StringBuffer resultat = new StringBuffer()
        byte[] buf = new byte[1024]
        int i = 0
        while ((i = input.read(buf)) != -1) {
            resultat.append(new String(buf, 0, i))
        }
        return resultat
    }

    /**
     * @return {@link Session}
     */
    private Session getSession()
    {
        return sessionFactory.getCurrentSession()
    }

}
